\documentclass[conference, 10pt, Ô¨Ånal, letterpaper, twocolumn]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage{stmaryrd}
\usepackage{amsfonts}
\usepackage{mathrsfs,amsmath}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{algorithmic} 
\usepackage{bm}
\usepackage{setspace}
\usepackage{amsthm}
\usepackage{empheq}
\usepackage{booktabs}
\usepackage{authblk}
\usepackage[ruled,linesnumbered,vlined]{algorithm2e}  
\usepackage{color}
\usepackage{enumerate}
\usepackage[left=0.65in, right=0.65in, top=0.7in, bottom = 0.98in]{geometry}
\usepackage{tabularx,booktabs}
\usepackage{ifpdf}
 \ifpdf
 \else
 \fi
\usepackage{cite}
\usepackage{threeparttable}
\ifCLASSINFOpdf
   \usepackage[pdftex]{graphicx}
\else
\fi
\usepackage{amsmath}
\usepackage[percent]{overpic}
\renewcommand{\algorithmicrequire}{\textbf{Input:}} 
\renewcommand{\algorithmicensure}{\textbf{Output:}} 
\usepackage{array} 
\usepackage{tikz,pgfplots,filecontents}
\usepackage{rotating}
\usetikzlibrary{spy} %
\pgfplotsset{width=8.6cm, height=6.5cm, compat=1.9}

\usetikzlibrary{calc}
\usepackage{pgfplotstable}
 
\ifCLASSOPTIONcompsoc 
  \usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
\else
  \usepackage[caption=false,font=footnotesize]{subfig}
\fi
 
\usepackage{url}
\usepackage{hyperref}

\makeatletter
\let\NAT@parse\undefined
\makeatother

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{corollary}[theorem]{Corollary}
 \newtheorem{remark}[theorem]{Remark}
\newtheorem*{pf}{Proof}
 
\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}
\hyphenation{}
\IEEEoverridecommandlockouts   
\renewcommand\thepage{}
\allowdisplaybreaks

\pagenumbering{arabic}

\pgfplotsset{every axis legend/.style={%
cells={anchor=west},
inner xsep=3pt,inner ysep=2pt,nodes={inner sep=0.8pt,text depth=0.15em},
anchor=north east,%
shape=rectangle,%
fill=white,%
draw=black,
at={(0.98,0.98)},
font=\footnotesize,
%line width=1pt,
%tick style={line width=0.8pt}
}}

\pgfplotsset{every axis/.append style={line width=0.6pt,tick style={line width=0.8pt}}}
%\setlength{\abovecaptionskip}{-0pt} 

%---------------------------------------------------------------------------------------------------


\begin{document}

\title{Less Carbon Footprint in Edge Computing: How Much May Task Offloading Help?}
 
\author{Zhanwei Yu\textsuperscript{1}, Yi Zhao\textsuperscript{1}, Tao Deng\textsuperscript{2}, Lei You\textsuperscript{3}, and Di Yuan\textsuperscript{1}}
\affil{\textsuperscript{1}Department of Information Technology, Uppsala University, Sweden
\authorcr \textsuperscript{2}School of Computer Science and Technology, Soochow University, China
\authorcr \textsuperscript{3}Department of Engineering Technology, Technical University of Denmark, Denmark
\authorcr {\em \textsuperscript{1}\{zhanwei.yu; yi.zhao; di.yuan\}@it.uu.se, \textsuperscript{2}dengtao@suda.edu.cn}, \textsuperscript{3}lei.you@pm.me}

% \author{Zhanwei Yu and Di Yuan}
% \affil{Department of Information Technology, Uppsala University, Sweden
% \authorcr {\em \{zhanwei.yu; di.yuan\}@it.uu.se}}

\renewcommand*{\Affilfont}{\small}

\maketitle

\begin{abstract}
To reduce the threats of more extreme climate, we aim to reduce carbon footprint (CF) in edge computing networks with renewable energy and batteries. Considering the spatial and temporal difference of carbon intensity of electricity among different regions, offloading the tasks to those edge servers in lower carbon-intensity areas can help reduce the total CF. In this paper, we consider scheduling and offloading the tasks as well as charging and discharging the batteries to minimize the total CF. We formulate this CF minimization problem as an integer linear programming, then we present the problem is equivalent to a min cost flow problem that can be solved to the optimum in polynomial time. Numerical results using real-world data show a significant carbon footprint reduction compared with two benchmark schemes.
\end{abstract}

\begin{IEEEkeywords}
carbon footprint, scheduling, edge computing.
\end{IEEEkeywords}


\section{Introduction}
The study in \cite{https://doi.org/10.48550/arxiv.2102.02622} points out that the current carbon footprint (CF) in information and communications technology (ICT) sector could be as high as $2.1\%$ to $3.9\%$, which is more than the $2\%$ that the baseline estimates for policy making in Europe. The authors of \cite{perrons2021digital} list four potential measures that can significantly help reduce the CF from the ICT industry, one of which is edge computing. 

The edge servers consumes substantially less energy than conventional cloud data centers though they need to be densely deployed. For achieving green edge computing, some works introduce some approaches to design the networks\cite{mao2017survey}, including dynamic right-sizing, geographical load balancing, and using renewable energy (RE). However, almost works with respect to green edge computing consider energy consumption or efficiency as the objective function, instead of CF. 

Although low energy consumption might imply low CF, they are not absolutely equivalent. For example, if we only focus on energy consumption in edge computing networks that have uniform servers, task transfer will be never considered because of more energy consumption. However, if we pursue low CF, we can transfer tasks to the low-CF areas, and complete them there. We show a set of the USA's domestic carbon intensity (CI) data and another set of European international one in table \ref{tab:data} from \cite{ElectricityMaps}. As we can see, a huge difference could occur between two regions due to the different power generation ways.  For example, the CI of Oregon is five times higher than that of Washington. Also, the CI of Oregon at 24:00 is reduced by 31.7\% compared with that at 08:00. This motivates us to use the spatial and temporal information of CI to reduce CF by charging scheduling and task offloading.  




\begin{table}[h]
    \caption{\label{tab:data}Two real-world sets of carbon intensity data}
    \begin{center}
        \begin{threeparttable}[b]
            \begin{tabular}{*{5}{llrrr}}
                \toprule
                \midrule
                 \multicolumn{2}{c}{\multirow{2}{*}{\bf Region}} & \multicolumn{3}{c}{\bf Carbon intensity\tnote{1}}\\
                 \cmidrule(lr){3-5}
                \multicolumn{2}{c}{} & 08:00 & 16:00 & 24:00 \\
                \midrule
                 \multirow{3}{*}{\begin{turn}{90} USA \end{turn}} & Washington & 110 & 95  & 95\\
                 & Oregon & 605 & 579 & 413\\
                 & California & 325 & 292  & 238\\
                \midrule
                 \multirow{3}{*}{\begin{turn}{90} Europe \end{turn}} & Sweden & 24 & 26 & 25\\
                 & Germany & 375 & 285 & 381\\
                 & Poland & 593 & 573 & 547\\
                \midrule
                \bottomrule
            \end{tabular}
            
            \begin{tablenotes}
            	\footnotesize
            	\item[1]Unit: g\ce{CO2}eq/kWh.
            \end{tablenotes}
        \end{threeparttable}
    \end{center}
\end{table}



The studies in \cite{van2012distributed, Rad2022Carbon, do2015proximal, aldossary2021towards, yang2022carbon} have addressed CF in edge computing or fog computing. The authors of \cite{van2012distributed} provide a model that can estimate the CF in distributed data centers. Their results show CF reductions are possible via distributed structure. The authors of \cite{Rad2022Carbon} provide a Lyapunov-based algorithm for a distributed data center to minimize electricity cost under a limit CF constraint. In \cite{do2015proximal}, the authors consider minimizing the CF for video streaming in fog computing networks. In addition, the studies in \cite{aldossary2021towards} and \cite{ahvar2021deca} both provide application placement methods to minimize the CF in fog computing networks. The authors of \cite{yang2022carbon} provide CI-aware task scheduling policy to minimize the CF of edge computing networks via the drift-plus-penalty methodology in Lyapunov optimization. 

To the best of our knowledge, the work in \cite{yang2022carbon} is the closest to ours as it also considers scheduling and offloading the tasks to minimize CF via the temporal and spatial information of CI. However, there are significant differences. Our system model includes multiple RE sources and batteries, so we need to optimize battery charging and discharging in addition to task offloading and scheduling. Thus, our model is more complexity than that of \cite{yang2022carbon}. The main contributions of this work are summarized as follows.
\begin{itemize}
    \item We show a edge computing network with RE sources and batteries, and discuss the CF in different parts of the network. We consider offloading and scheduling the tasks, and charging and discharging the batteries to reduce the total CF. 
    \item We formulate this CF minimization problem as integer linear programming (ILP). Then we provide a method based on network flow that can solve the CF minimization problem in polynomial time though it is ILP.
    \item We use real-world date to evaluate the performance. Compared with two benchmark schemes, the numerical results show a significant CF reduction. In addition, the results also show that our method can help reduce the total cost as well. {\color{red}(will add specific percentage reduction later...)}
\end{itemize}

\section{System Model and Problem Formulation}

\input{fig-system_model}

\subsection{System Model}
We consider an edge computing network illustrated in Fig. \ref{fig:system_model}, which consists of $S$ edge computing servers. We use $\mathcal{S} = \{1,2,...,S\}$ to represent the sites illustrated by dashed rectangles in Fig. \ref{fig:system_model} including an edge computing server, a battery, a RE source, and the local grid. All the batteries are connected to each other in the battery management system (BMS), hence the energy in a battery can be used for servers in other sites. In this paper, we use the index of the site to refer to its associated devices, e.g., server $s$, battery $s$, etc. More specifically,
\begin{itemize}
    \item A server can be powered by its local grid, its associated renewable energy source, and all the batteries. 
    \item The battery, associated with a computing server, can be charged by the local grid and its associated renewable energy source. Additionally, the battery can provide energy for any other servers with an energy transfer loss.
\end{itemize}

\subsection{Time Slotted Horizon}
We consider a scheduling horizon divided into $T$ time slots, denoted by $\mathcal{T} = \{1,2,...,T\}$. The tasks that are the same type in the network (i.e., the amount of energy to handle them are the same) is represented by $\mathcal{N} = \{1, 2, ..., N\}$. Any task $n$ is represented by a tuple $(o_n, d_n, s_n, \mathcal{S}_n)$ where $o_n, d_n \in \mathcal{T}, s_n \in \mathcal{S}, \mathcal{S}_n \subseteq \mathcal{S}$, and
\begin{itemize}
    \item $o_n$ is the time slot when the task can be handled;
    \item $d_n$ is the deadline of completing the task;
    \item $s_n$ is the server that the task is initially associated with;
    \item $\mathcal{S}_n$ is the set of candidate servers that can do task $n$.
\end{itemize}
The tasks can be offloaded among the their candidate servers, and we assume that all the servers have the same specification and computing power, i.e., the amounts of energy that different servers require to complete a task are the same, denoted by $E$ (kWh). For convenience, all the related parameters (e.g., $R$-, $I$-, $\alpha$-, and $\beta$-parameters to be introduced next) are normalized by $E$ such that a task completes in a unit of energy.

For the tasks, denote by $x_{nst}$, $y_{nss^\prime t}$, and $z_{nst}$ binary variables that is one if and only if task $n$ is completed by server $s$ using energy in time slot $t$ from the local grid, battery $s^\prime$ and RE source, respectively. For any task, it only needs to be handled by a server in a time slot, so we have
\begin{equation}\label{c1}
    \sum_{s \in \mathcal{S}} \sum^{d_n}_{t = o_n} ( x_{nst} + \sum_{s^\prime \in S_n}  y _{nss^\prime t} + z_{nst}) = 1, \forall n \in \mathcal{N}.
\end{equation}

For the batteries, we use integer variables $u_{st}$ and $v_{st}$ to represent the amount of charging battery $s$ from the local grid and RE at the beginning of time slot $t$, respectively. In addition, denote by integer variable $w_{st}$ the remaining energy of battery $s$ in the end of time slot $t$. We use $L$ to present the capacity of the battery. At the beginning of time slot $t$, we have the following battery capacity constraint:
\begin{equation}\label{c2}
    u_{st} + v_{st} + w_{s(t-1)} \leq L, \forall s \in \mathcal{S}, t \in \mathcal{T} \setminus \{1\}.
\end{equation}
At the end of that, the remaining energy $w_{st}$ is calculated by
\begin{equation}\label{c3}
    w_{st} = u_{st} + v_{st} + w_{s(t-1)} - \sum_{n\in\mathcal{N}} \sum_{s^\prime \in \mathcal{S}_n} y_{nss^\prime t}, \forall s \in \mathcal{S}, t \in \mathcal{T} \setminus \{1\}.
\end{equation}

For the servers, $H$ is the maximum amount of tasks that can be handled by a server in a time slot. Note that the required energy of a task is one unit, so we have the following constraint:
\begin{equation}\label{c4}
    \sum_{n \in \mathcal{N}}(x_{nst}+\sum_{s^\prime \in\mathcal{S}} y_{nss^\prime t} +z_{nst}) \leq H, \forall s \in \mathcal{S}, t \in \mathcal{T}.
\end{equation}

We use $I_{st}$ and $R_{st}$ to denote the carbon intensity of local grid $s$ and the amount of renewable energy from source $s$ in time slot $t$, respectively\footnote{The prediction data can be obtained from for example \cite{ElectricityMaps} and \cite{li2019renewable}, respectively.}. They are both normalized by $E$, and the unit of $I_{st}$ is g\ce{CO2}eq/$E$kWh that means the equivalent gram of \ce{CO2} generation per $E$ kilowatt-hour energy. For the energy from RE sources, we have the following constraint:
\begin{equation}\label{c5}
    z_{nst} + u_{st} \leq R_{st}, \forall s \in \mathcal{S}, t \in \mathcal{T}.
\end{equation}

\subsection{Carbon Footprint and Formulation} \label{subsec:CFA}

In the system model, the CF occurs only in three processes related to the grids, including battery charging, task completing, and tasks transmission. Specifically,
\begin{enumerate}
    \item {\em Tasks handling}: The total amount of CF from task handling in the network is expressed as
    \begin{equation}\label{th}
        Th(\boldsymbol{x}) = \sum_{t \in \mathcal{T}} \sum_{s\in \mathcal{S}} \sum_{n\in \mathcal{N}} I_{st}x_{nst}.
    \end{equation}
    \item {\em Battery charging}: Similarly, the total amount of CF occurring in battery charging in the network can be calculated by
    \begin{equation}\label{bc}
        Bc(\boldsymbol{u}) = \sum_{t \in \mathcal{T}} \sum_{s\in \mathcal{S}} I_{st}u_{st}.
    \end{equation}
    \item {\em Tasks transfer}: We use $\alpha_{s_n s}$ to represent the required energy for task $n$ transfer from its initial server $s_n$ to $s$ ($\alpha_{s_n s} = 0$ if $s_n = s$), so the total amount of CF from task transfer in the network is given by
    \begin{align}\label{tt}
        &Tt(\boldsymbol{x}, \boldsymbol{y}, \boldsymbol{z}) = \notag \\
        & \sum_{n \in \mathcal{N}} \sum_{s \in \mathcal{S}} \alpha_{s_n s} \sum^{d_n}_{t = o_n} I_{st} ( x_{nst} + \sum_{s^\prime \in S_n}  y _{nss^\prime t} + z_{nst}).
    \end{align}
\end{enumerate}
In addition, there are losses in the energy transfer between the battery to the servers in other sites. We convert this loss to equivalent CF such that we can analyze the CF more explicitly. Furthermore, we denote the energy loss per unit of energy from the battery $s^\prime$ to server $s$ by $\beta_{s^\prime s}$ ($\beta_{s^\prime s} = 0$ if $s^\prime = s$). We suppose that local grid $s$ provides energy to make up for the loss, so the total amount of the equivalent CF with respect to loss is 
\begin{equation}\label{lo}
    Lo(\boldsymbol{y}) = \sum_{n \in \mathcal{N}} \sum_{s \in \mathcal{S}} I_{st} \sum^{d_n}_{t = o_n}\sum_{s^\prime \in S_n}  \beta_{s^\prime s}  y _{nss^\prime t}.
\end{equation}

We consider minimizing the total CF in the edge computing network via offloading and scheduling the tasks, and charging and discharging the batteries. The CF minimization problem can be formulated by integer linear programming (ILP) as follows,
\begin{subequations}\label{formulation}
    \begin{align}
         \mathop{\min}_{\boldsymbol{x}, \boldsymbol{y}, \boldsymbol{z}, \boldsymbol{u}, \boldsymbol{v}, \boldsymbol{w}} \ &Th(\boldsymbol{x}) +  Bc(\boldsymbol{u}) + Tt(\boldsymbol{x}, \boldsymbol{y}, \boldsymbol{z}) + Lo(\boldsymbol{y}) \label{obj}\\
         \text{s.t.} & \quad \eqref{c1} - \eqref{c5},\notag\\
         & \quad x\text{-}\text{, } y\text{-}\text{, and } z\text{-variables} \in \{0,1\},\\
         & \quad u\text{-}\text{, } v\text{-}\text{, and } w\text{-variables} \in \mathbb{N},
    \end{align}
\end{subequations}
where the objective function \eqref{obj} is the overall CF from the network.

\section{Problem Solving} 

\input{fig-networkflow}

Although the CF minimization problem is formulated as ILP in \eqref{formulation}, it corresponds to a min cost flow problem that can be solved in polynomial time. We show the corresponding graph in Fig. \ref{fig:networkflow}. Generally speaking, the flows in the graph represent the energy transfers, and the costs of edges are the CF of the corresponding processes. The green and the yellow nodes are supply and demand nodes, respectively, and the sum of supply is equal to the sum of demand.

Let us introduce the detail of the graph. Note that the costs and capacities of edges default to zero and infinite if we do not specify them, respectively. The green and yellow nodes are supply and demanded nodes, respectively, and the other colored nodes are all transshipment nodes. In addition, we use $(a\rightarrow b)$ to represent the directed edge from node $a$ to node $b$.

\subsection{Perspective of a time slot}

As we can see, except all the yellow nodes and the green node $\delta$, the nodes can be divided into $T$ parts by time slots. Looking into a part, there are three types of entities that are $\theta$-nodes, $(\kappa, \rho)$-pairs, and $(\lambda, \varepsilon)$-pairs:
\begin{enumerate}
    \item Any green node $\theta^{t}_{s}$ is the supply node in the graph, and its quantity supplied represents how many units of energy RE source $s$ can provide in time slot $t$, i.e., $R_{st}$. Two flows from node $\theta^{t}_{s}$ to nodes $\lambda^{t}_{s}$ and $\kappa^{t}_{s}$ represent the variables $z_{st}$ and $u_{st}$, respectively. By the definition of networkflow graph, these two flows follow constraint \eqref{c5}. Note that node $\theta^{t}_{s}$ also connects to yellow demanded node $\mu$, and node $\mu$ is used for receiving the surplus flows (i.e., surplus energy) in the graph to guarantee the feasibility of the min cost flow problem.
    \item In any red pair $(\kappa^{t}_{s}, \rho^{t}_{s})$, both the two nodes are transshipment nodes. The capacity of edge $(\kappa^{t}_{s}\rightarrow \rho^{t}_{s})$ is set to be the capacity of battery $s$, i.e., $L$. The flows to node $\kappa^{t}_{s}$ from nodes $\delta$, $\theta^{t}_{s}$, and $\rho^{t-1}_{s}$ are equivalent to variables $u_{st}$, $v_{st}$, and $w_{s(t-1)}$, respectively, and they follow constraint \eqref{c2} by the definition of networkflow graph.
    \item Any blue pair $(\lambda^{t}_{s}, \varepsilon^{t}_{s})$ represents server $s$ in time slot $t$, the two nodes of which are both transshipment nodes. The capacity of edge $(\lambda^{t}_{s}\rightarrow\varepsilon^{t}_{s})$ is the amount of energy required when server $s$ fully handles tasks in time slot $t$, i.e., $H$. Similarly, the flows to $\lambda^{t}_{s}$ from nodes $\delta$, $\rho^{t}_{s^\prime}$, and $\theta^{t}_{s}$ represent variables $x_{nst}$, $y_{nss^\prime t}$ ($\forall s^\prime \in \mathcal{S}$), and $z_{nst}$, and these flows follow constraint \eqref{c4}. Note that the flow through edge $(\rho^{t}_{s^\prime}\rightarrow\lambda^{t}_{s})$ represents that battery $s^\prime$ provides energy to server $s$ in time slot $t$, so the cost of the edge is $\beta_{s^\prime s} I_{st}$, and it accounts for the losses in tasks transfer. Clearly, the total flow cost in these edges equals to \eqref{lo}.
\end{enumerate}

\subsection{Perspective of two neighbor time slots}
Between any two neighbor time slots $t$ and $t+1$, there are $S$ edges, i.e., $(\rho^{t}_{s}\rightarrow\kappa^{t+1}_{s})$ $\forall s\in \mathcal{S}$. The edges mean the evolution of the batteries between time slots $t$ and $t+1$. According to flow balance constraint in networkflow graph, node $\kappa^{t+1}_{s}$ will receive flows that are from node $\rho^{t}_{s}$ except these to node $\lambda^{t}_{s}$, i.e., this flow balance constraint derives constraint \eqref{c3}.

\subsection{Perspective of the grids}

We also can see that there are two types of edges from supply node $\delta$:
\begin{enumerate}
    \item Flows can be sent through the edge $(\delta \rightarrow\kappa^{t}_{s})$, and this represents local grid $s$ charge battery $s$ in time slot $t$. Clearly, its cost is $I_{st}$ that accounts for CF in battery charging, and the total flow cost in these edges is the same as \eqref{bc}.
    \item We use flows through edge $(\delta \rightarrow \lambda^{t}_{s})$ represent local grid $s$ provide energy to server $s$ in time slot $t$, so the cost of edge $(\delta \rightarrow \lambda^{t}_{s})$ is set to be $I_{st}$. The cost is used for accounting for CF in task handling, and the sum of flow cost in these edges is equivalent to \eqref{th}.
\end{enumerate}
There is also an edge from node $\delta$ to node $\mu$ that is used for receiving the surplus flows from the grid. The number of node $\delta$'s supplied flows is large enough, e.g., $N$. 

\subsection{Perspective of the tasks}

Let us look into the part named Tasks in the graph where yellow demand node $\tau_n$ represents task $n$. The quantity demanded of any node $\tau_n$ is one. We set the edges between $\varepsilon$-nodes and $\tau$-nodes by the information of all the tasks' tuples. Specifically, any edge from blue node $\varepsilon^{t}_{s}$ to yellow node $\tau_{n}$ represents that server $s$ can handle task $n$ in time slot $t$ ($o_n \leq t \leq d_n$). According to the flow balance constraint, the sum of the flows from nodes $\delta$, $\rho^{t}_{s^\prime}$ ($\forall s^\prime \in \mathcal{S}$), and $\theta^{t}_{s}$ is one. So, the variables that these flows are equivalent to follow constraint \eqref{c1}.

Regarding the cost of the edges, we use the cost of the edges to account for the CF in task transfer. Note that we have used the cost of edge $(\delta\rightarrow\lambda^{t}_{s})$ to account for the CF of task $n$ handled by server $s$ in time slot $t$. Therefore, the cost of edge $(\varepsilon^{t}_{s}\rightarrow\tau_n)$ is $\alpha_{s_{n}s}I_{s_{n}t}$. Obviously, the sum of flow cost in these edges is equivalent to \eqref{tt}.

\subsection{Algorithms}

We have introduced all the nodes and edges in the graph, and we have shown all the constraints of Problem \eqref{formulation} have corresponding constraint in the min cost flow problem. In addition, by setting the costs of different edges, the objective function of the min cost flow problem is equivalent to \eqref{obj}. The min cost flow problem can be solved by existing algorithms in polynomial time \cite{10.5555/137406}, for example, the network simplex algorithm.

\section{Performance Evaluation}


In this section, we use one-day CI data of Sweden, Germany, and Poland from \cite{ElectricityMaps} to evaluate the performance of our proposed method. In our simulation, the length of a time slot is an hour. We assume that 7 am to 7 pm are daytime, and the other hours are night. The REs in daytime for time slot follow a binomial distribution $B(5, 0.5)$, and in night they are set to be zero. In addition, all the tasks' $o_{n}$, $d_n$ ($o_n \leq d_n$), and $s_n$ all follow discrete uniform distribution. In addition, we set $\mathcal{S}_n = \mathcal{S}$ $\forall n \in \mathcal{N}$, i.e., all the tasks can be offloaded among all the servers. Other simulation parameters are listed in Table \ref{tab:parameters}. Note that the values of CF in our results are all normalized by $E$. 

\begin{table}[h]
    \caption{\label{tab:parameters}Simulation Parameters}
    \begin{center}
        \begin{threeparttable}[b]
            \begin{tabular}{*{2}{lr}}
                \toprule
                \midrule
                {\bf Parameter} & {\bf Value}\\
                \midrule
                 The number of time slots $T$ & $24$ \\
                 The number of servers $S$ & $3$\\
                 The number of tasks $N$ & $100$\\
                 The energy for one task transfer $\alpha$ & 0.1\\
                 Loss for one unit of energy transfer $\beta$ & $0.2$\\
                \bottomrule
            \end{tabular}
        \end{threeparttable}
    \end{center}
\end{table}

\input{result1}

Fig. \ref{fig:result1} shows the performance results of our propose method for various battery capacity $L$ and server capacity $H$. As we can see that there is a drastic reduction (almost a half) of CF when battery capacity becomes $5$ from $0$ for any server capacity. This is because we can schedule and share low-CF energy among the servers via battery and BMS. When battery capacity $L$ is greater than $15$, the total CF is hardly changed because the batteries can already store all the energy required by all the tasks when $L = 15$. In addition, when the server capacity increases, the total CF decreases as more tasks can be offloaded to those servers in low-CI areas.

\input{result2}

\input{result3}

We also compare our method with three benchmark schemes. (which countries as data)





\section{Conclusion} \label{Sec:conclusion}


\bibliographystyle{IEEEtran}
\bibliography{mybibtex}


\end{document}
